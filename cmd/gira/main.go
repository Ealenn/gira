package main

import (
	"os"
	"strconv"

	"github.com/Ealenn/gira/internal/commands"
	"github.com/Ealenn/gira/internal/configuration"
	"github.com/Ealenn/gira/internal/log"
	"github.com/Ealenn/gira/internal/ui"
	"github.com/Ealenn/gira/internal/version"

	"github.com/spf13/cobra"
)

var verbose bool
var profile *configuration.Profile
var currentProfileName string

func preRun(logger *log.Logger, configuration *configuration.Configuration, version *version.Version) {
	profile = configuration.GetProfile(currentProfileName)
	logger.Debug("Current Profile Name : %s", currentProfileName)
	logger.Debug("Profile exist : %s", strconv.FormatBool(profile != nil))

	ui.CheckConfiguration(logger, profile, configuration)
	ui.CheckUpdate(logger, configuration, version)
}

func main() {
	logger := log.New(&verbose)
	version := version.New()
	configuration := configuration.New(logger)

	rootCmd := &cobra.Command{
		Use:     "gira",
		Version: version.GetCurrentVersion(),
		Short:   "Gira is a CLI tool that connects your Git workflow with Jira, letting you automate tasks like branch creation and issue updates directly from your terminal.",
		Long: `
Gira is a simple and powerful command-line tool that bridges your Git workflow with Jira.
It helps you automate common development tasks such as creating Git branches from Jira issues, updating issue statuses, or closing issues â€” all without leaving your terminal.
With Gira, you can streamline your development processes, eliminate repetitive copy-pasting between Jira and Git, and ensure your issue tracking stays in sync with your commits.
Use Gira to accelerate your workflow and keep your projects organized more efficiently.
		`,
	}

	// Global
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "", false, "Print detailed operation logs and debug information")
	rootCmd.PersistentFlags().StringVarP(&currentProfileName, "profile", "", "default", "Configuration profile to use")

	/* ----------------------
	 * Branch
	 * ----------------------
	 */
	var branchCommandAssignIssueFlag bool
	var branchCommandForceFlag bool
	var branchCommand = &cobra.Command{
		Use:   "branch [issue]",
		Short: "Create a new Git branch using issue",
		Long: `
Creates a new Git branch based on issue.
The branch name is generated by combining the issue ID with a slugified version of the issue summary (e.g., "feature/ABC-123/fix-login-bug"). 
This helps enforce consistent naming conventions and improve traceability between code and issues.`,
		Example: "  gira branch ISSUE-123\n  gira branch -a ISSUE-123",
		Aliases: []string{"checkout"},
		Args:    cobra.MinimumNArgs(1),
		Run: func(_ *cobra.Command, args []string) {
			preRun(logger, configuration, version)
			commands.NewBranch(logger, configuration, profile).Run(args[0], branchCommandAssignIssueFlag, branchCommandForceFlag)
		},
	}
	branchCommand.Flags().BoolVarP(&branchCommandAssignIssueFlag, "assign", "a", false, "assign the issue to the currently logged-in user after creating the Git branch")
	branchCommand.Flags().BoolVarP(&branchCommandForceFlag, "force", "f", false, "disable interactive prompts and force branch creation even if checks would normally prevent it")
	rootCmd.AddCommand(branchCommand)

	/* ----------------------
	 * Issue
	 * ----------------------
	 */
	var issueCommand = &cobra.Command{
		Use:   "issue [ID]",
		Short: "Show details of an issue (from current branch or specified issue ID)",
		Long: `
Displays detailed information about an issue.

If no issue ID is provided, the issue associated with the current Git branch is used.
If an issue ID is specified, the command will display information for that issue.

This includes the issue key, summary, description, status, priority, assignee, and other relevant metadata.
Useful for quickly reviewing the context of your work without leaving the terminal.`,
		Example: "  gira issue\n  gira issue ABC-123",
		Args:    cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, args []string) {
			preRun(logger, configuration, version)

			var issueID *string
			if len(args) > 0 {
				issueID = &args[0]
			}
			commands.NewIssue(logger, configuration, profile).Run(issueID)
		},
	}
	rootCmd.AddCommand(issueCommand)

	/* ----------------------
	 * Config
	 * ----------------------
	 */
	var configListFlag bool
	var configCommand = &cobra.Command{
		Use:   "config",
		Short: "Configure Gira profile with accounts and tokens",
		Long: `
This command sets up the Gira CLI by allowing you to configure one or more accounts, each with its own credentials.
You can create multiple profiles to connect to different sources, making it easy to switch between environments or accounts.

For each profile, you'll provide the URL and tokens.
This information is stored in your configuration file and enables Gira to communicate with the specified instance when running commands like branch or issue`,
		Aliases: []string{"configure"},
		Args:    cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, _ []string) {
			commands.NewConfig(logger, configuration, profile).Run(currentProfileName, configListFlag)
		},
	}
	configCommand.Flags().BoolVarP(&configListFlag, "list", "l", false, "list all available profiles")
	rootCmd.AddCommand(configCommand)

	/* ----------------------
	 * Version
	 * ----------------------
	 */
	var versionCommand = &cobra.Command{
		Use:   "version",
		Short: "Display the current Gira version and check for available updates",
		Long: `
Displays the currently installed version of the Gira CLI.
Also checks the GitHub repository to determine if a newer version is available for download, helping you stay up-to-date with the latest features and fixes.`,
		Args: cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, _ []string) {
			commands.NewVersion(logger, configuration, profile).Run()
		},
	}
	rootCmd.AddCommand(versionCommand)

	/* ----------------------
	 * Application
	 * ----------------------
	 */
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

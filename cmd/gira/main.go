package main

import (
	"os"
	"strconv"

	"github.com/Ealenn/gira/internal/branch"
	"github.com/Ealenn/gira/internal/command"
	"github.com/Ealenn/gira/internal/configuration"
	"github.com/Ealenn/gira/internal/git"
	"github.com/Ealenn/gira/internal/issue"
	"github.com/Ealenn/gira/internal/log"
	"github.com/Ealenn/gira/internal/ui"
	"github.com/Ealenn/gira/internal/version"

	"github.com/spf13/cobra"
)

var (
	verbose            bool
	profile            *configuration.Profile
	gitManager         *git.Git
	branchManager      *branch.Manager
	tracker            issue.Tracker
	currentProfileName string
	enableAI           bool
)

func preProfile(logger *log.Logger, config *configuration.Configuration) {
	profile = config.GetProfile(currentProfileName)
	logger.Debug("Current Profile Name : %s", currentProfileName)
	logger.Debug("Profile exist : %s", strconv.FormatBool(profile != nil))

	gitManager = git.NewGit(logger)

	if profile != nil {
		switch profile.Type {
		case configuration.ProfileTypeJira:
			tracker = issue.NewJira(logger, profile, gitManager)
		case configuration.ProfileTypeGithub:
			tracker = issue.NewGitHub(logger, profile, gitManager)
		}

		branchManager = branch.NewBranchManager(logger, gitManager, tracker)
	}
}

func preRun(logger *log.Logger, configuration *configuration.Configuration, version *version.Version) {
	preProfile(logger, configuration)
	ui.CheckConfiguration(logger, configuration, currentProfileName, profile)
	ui.CheckUpdate(logger, configuration, version)
}

func main() {
	logger := log.New(&verbose)
	version := version.New(logger)
	configuration := configuration.New(logger)

	rootCmd := &cobra.Command{
		Use:     "gira",
		Version: version.GetCurrentVersion(),
		Short:   "Gira is a CLI tool that connects your Git workflow with Jira & Github, letting you automate tasks like branch creation and issue updates directly from your terminal.",
		Long: `
Gira is a simple and powerful command-line tool that bridges your Git workflow with Jira & Github.
It helps you automate common development tasks such as creating Git branches from issues, updating issue statuses, or closing issues â€” all without leaving your terminal.
With Gira, you can streamline your development processes, eliminate repetitive copy-pasting between Issues and Git, and ensure your issue tracking stays in sync with your commits.
Use Gira to accelerate your workflow and keep your projects organized more efficiently.
		`,
	}

	// Global
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "", false, "print detailed operation logs and debug information")
	rootCmd.PersistentFlags().StringVarP(&currentProfileName, "profile", "p", "default", "configuration profile to use")
	rootCmd.PersistentFlags().BoolVarP(&enableAI, "ai", "", false, "enable AI-powered features, such as branch name suggestions and other smart assistance")

	/* ----------------------
	 * Branch
	 * ----------------------
	 */
	var branchCommandAssignIssueFlag bool
	var branchCommandForceFlag bool
	var branchCommand = &cobra.Command{
		Use:   "branch [issue]",
		Short: "Create a new Git branch using issue",
		Long: `
Creates a new Git branch based on issue.
The branch name is generated by combining the issue ID with a slugified version of the issue summary (e.g., "feature/ABC-123/fix-login-bug"). 
This helps enforce consistent naming conventions and improve traceability between code and issues.`,
		Example: "  gira branch ISSUE-123\n  gira branch -a ISSUE-123",
		Aliases: []string{"checkout"},
		Args:    cobra.MinimumNArgs(1),
		Run: func(_ *cobra.Command, args []string) {
			preRun(logger, configuration, version)
			command.NewBranch(logger, tracker, gitManager, branchManager).Run(args[0], branchCommandAssignIssueFlag, enableAI, branchCommandForceFlag)
		},
	}
	branchCommand.Flags().BoolVarP(&branchCommandAssignIssueFlag, "assign", "a", false, "assign the issue to the currently logged-in user after creating the Git branch")
	branchCommand.Flags().BoolVarP(&branchCommandForceFlag, "force", "f", false, "disable interactive prompts and force branch creation even if checks would normally prevent it")
	rootCmd.AddCommand(branchCommand)

	/* ----------------------
	 * Dashboard
	 * ----------------------
	 */
	var dashboardStatusFlag *string
	var dashboardCommand = &cobra.Command{
		Use:   "dash [issue]",
		Short: "Open your issue dashboard",
		Long: `
This command gives you a project-wide snapshot of your issues without leaving the terminal.

It opens an interactive dashboard that lists issues by status (open, in-progress, or closed).

This makes it easy to switch from working on a single issue to seeing the bigger picture of your team's progress.`,
		Example: "  gira dash",
		Aliases: []string{"dashboard"},
		Args:    cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, _ []string) {
			preRun(logger, configuration, version)
			command.NewDashboard(logger, profile, tracker).Run(dashboardStatusFlag, enableAI)
		},
	}
	dashboardStatusFlag = dashboardCommand.Flags().StringP("status", "s", "all", "filter issues by status")
	rootCmd.AddCommand(dashboardCommand)

	/* ----------------------
	 * Ninja
	 * ----------------------
	 */
	var ninjaCommandForceFlag bool
	var ninjaCommand = &cobra.Command{
		Use:     "ninja",
		Short:   "Create a new issue and associated branch in one command",
		Long:    ``,
		Aliases: []string{"doh", "oops"},
		Args:    cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, _ []string) {
			preRun(logger, configuration, version)
			command.NewNinja(logger, profile, tracker, gitManager, branchManager).Run(enableAI, ninjaCommandForceFlag)
		},
	}
	ninjaCommand.Flags().BoolVarP(&branchCommandForceFlag, "force", "f", false, "disable interactive prompts and force branch creation even if checks would normally prevent it")
	rootCmd.AddCommand(ninjaCommand)

	/* ----------------------
	 * Issue
	 * ----------------------
	 */
	var issueCommand = &cobra.Command{
		Use:   "issue [ID]",
		Short: "Show details of an issue (from current branch or specified issue ID)",
		Long: `
Displays detailed information about an issue.

If no issue ID is provided, the issue associated with the current Git branch is used.
If an issue ID is specified, the command will display information for that issue.

This includes the issue key, summary, description, status, priority, assignee, and other relevant metadata.
Useful for quickly reviewing the context of your work without leaving the terminal.`,
		Example: "  gira issue\n  gira issue ABC-123",
		Args:    cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, args []string) {
			preRun(logger, configuration, version)

			var issueID *string
			if len(args) > 0 {
				issueID = &args[0]
			}
			command.NewIssue(logger, tracker, gitManager, branchManager).Run(issueID, enableAI)
		},
	}
	rootCmd.AddCommand(issueCommand)

	/* ----------------------
	 * Open
	 * ----------------------
	 */
	var openCommand = &cobra.Command{
		Use:   "open  [ID]",
		Short: "Open issue in web browser (from current branch or specified issue ID)",
		Long: `
Open issue in web browser.

If no issue ID is provided, the issue associated with the current Git branch is used.
If an issue ID is specified, the command will display information for that issue.
		`,
		Aliases: []string{"web"},
		Args:    cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, args []string) {
			preRun(logger, configuration, version)

			var issueID *string
			if len(args) > 0 {
				issueID = &args[0]
			}
			command.NewOpen(logger, branchManager, tracker).Run(issueID)
		},
	}
	rootCmd.AddCommand(openCommand)

	/* ----------------------
	 * Config
	 * ----------------------
	 */
	var configListFlag bool
	var configRemoveFlag bool
	var configCommand = &cobra.Command{
		Use:   "config",
		Short: "Configure Gira profile with accounts and tokens",
		Long: `
This command sets up the Gira CLI by allowing you to configure one or more accounts, each with its own credentials.
You can create multiple profiles to connect to different sources, making it easy to switch between environments or accounts.

For each profile, you'll provide the URL and tokens.
This information is stored in your configuration file and enables Gira to communicate with the specified instance when running commands like branch or issue`,
		Aliases: []string{"configure"},
		Args:    cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, _ []string) {
			preProfile(logger, configuration)
			command.NewConfig(logger, configuration, profile).Run(currentProfileName, configListFlag, configRemoveFlag)
		},
	}
	configCommand.Flags().BoolVarP(&configListFlag, "list", "l", false, "list all available profiles")
	configCommand.Flags().BoolVarP(&configRemoveFlag, "remove", "r", false, "remove selected profile")
	rootCmd.AddCommand(configCommand)

	/* ----------------------
	 * Version
	 * ----------------------
	 */
	var versionCommand = &cobra.Command{
		Use:   "version",
		Short: "Display the current Gira version and check for available updates",
		Long: `
Displays the currently installed version of the Gira CLI.
Also checks the GitHub repository to determine if a newer version is available for download, helping you stay up-to-date with the latest features and fixes.`,
		Args: cobra.MinimumNArgs(0),
		Run: func(_ *cobra.Command, _ []string) {
			preProfile(logger, configuration)
			command.NewVersion(logger, configuration, version).Run()
		},
	}
	rootCmd.AddCommand(versionCommand)

	/* ----------------------
	 * Application
	 * ----------------------
	 */
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}
